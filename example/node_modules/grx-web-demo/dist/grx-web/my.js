"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = exports.server = void 0;
exports.next = next;
const http_1 = require("http");
const url_1 = require("url");
//存储所有注册的路由
// const routers: Router[] = [];
//更新map键值对 存储所有的路由
const routers = new Map();
//中间件存储结构
const middlewares = [];
//中间件next函数
async function next(ctx, index = 0, middlewaredData = new Map) {
    //中间件处理
    if (index >= middlewares.length) {
        return;
    }
    await middlewares[index](ctx, async () => {
        //中间件处理完成 返回信息
        const middlewaredData = ctx.middlewaredData;
        console.log(middlewaredData);
        //递归调用
        await next(ctx, index + 1, middlewaredData);
    }, ctx.middlewaredData);
}
//创建http服务器
exports.server = (0, http_1.createServer)(async (req, res) => {
    //创建上下文对象 ctx
    const ctx = {
        req,
        res,
        json: (input) => {
            res.writeHead(200, { "Content-Type": "application/json" });
            res.end(JSON.stringify(input));
        },
        middlewaredData: new Map(),
        getMiddlewareData(key) {
            return this.middlewaredData.get(key);
        },
        setMiddlewareData(key, value) {
            this.middlewaredData.set(key, value);
        }
    };
    //中间件处理
    await next(ctx);
    try {
        //处理中间件
        await next(ctx);
        //url 解析对象
        const url = new url_1.URL(req.url || '/', 'http://$(req.headers.host)');
        url.pathname = normalized(url.pathname);
        //处理路由
        console.log('处理准备开始');
        await handler(ctx, req, res, url);
        console.log('处理完成');
    }
    catch (error) {
        res.statusCode = 500;
        res.end('Internal Server Error');
        console.log(error);
    }
});
async function handler(ctx, req, res, url) {
    //老方法遍历所有注册的路由，每次都需要完整遍历
    // for (const router of routers) { 
    //     //判断当前请求的路径和注册的路径是否匹配
    //     //标准化路径
    //     url.pathname = normalized(url.pathname);
    //     if (router.method === req.method && url.pathname === router.url) { 
    //         //执行处理函数
    //         //trycatch
    //         try { 
    //             await router.handler(ctx);
    //         } catch (error) { 
    //             res.statusCode = 500;
    //             res.end('Internal Server Error');
    //             console.log(error);
    //         }
    //         return;
    //     }
    //     else { 
    //         continue;
    //     }
    // }
    //新方法:mAp 存储所有路由
    //提取选择的方法 首先保证方法存在 换为URL后没这个问题了
    // if (!url.pathname) {
    //     res.statusCode = 400;
    //     res.end('Bad Request');
    //     return;
    // }
    if (req.method) {
        const map = routers.get(req.method);
        //标准化
        //如果没有找到 即url不匹配
        if (!map) {
            res.statusCode = 404;
            res.end('Not Found');
            return;
        }
        //查找对应的处理函数
        const handler = map.get(url.pathname);
        //如果没有找到
        if (!handler) {
            res.statusCode = 404;
            res.end('Not Found');
            return;
        }
        //执行处理函数
        try {
            await handler(ctx);
        }
        catch (error) {
            res.statusCode = 500;
            res.end('Internal Server Error');
            console.log(error);
        }
    }
}
function normalized(url) {
    let pathname = url;
    //如果路径开头没有/
    if (!pathname.startsWith('/')) {
        pathname = '/' + pathname;
    }
    //如果有参数
    const queryIndex = pathname.indexOf('?');
    if (queryIndex != -1) {
        pathname = pathname.substring(0, queryIndex);
    }
    //如果路径结尾没有/
    if (!pathname.endsWith('/')) {
        pathname = pathname + '/';
    }
    return pathname;
}
//router对象
exports.router = {
    //注册中间件
    use: (middleware) => {
        middlewares.push(middleware);
    },
    //注册get路由 url表示要匹配的url路径 cb表示处理函数
    get: (url, cb) => {
        //获取标准化的路径
        url = normalized(url);
        //routers.push({method:'GET', url, handler:cb});
        //get方法并不需要返回值
        // return {method:'GET',url, handler:cb};
        const method = 'GET';
        const map = routers.get(method) || new Map();
        map.set(url, cb);
        routers.set(method, map);
    },
    post: (url, cb) => {
        //获取标准化的路径
        url = normalized(url);
        //routers.push({method:'POST',url, handler:cb});
        const method = 'POST';
        const map = routers.get(method) || new Map();
        map.set(url, cb);
        routers.set(method, map);
        return { method: 'POST', url, handler: cb };
    }
};
